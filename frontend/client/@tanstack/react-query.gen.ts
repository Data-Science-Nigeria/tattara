// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  authControllerRegister,
  authControllerLogin,
  authControllerLogout,
  authControllerVerifyEmail,
  authControllerResendVerification,
  authControllerForgotPassword,
  authControllerResetPassword,
  authControllerGetProfile,
  authControllerRefreshToken,
  userControllerGetProfile,
  userControllerFindAll,
  userControllerFindAllForLoggedInUser,
  userControllerAssignRole,
  userControllerGetAllRoles,
  userControllerRegisterSingleUser,
  userControllerBulkCreate,
  userControllerGetAllPermissions,
  programControllerGetPrograms,
  programControllerCreate,
  programControllerRemove,
  programControllerFindOne,
  programControllerUpdate,
  programControllerFindWorkflowsByProgram,
  programControllerAddWorkflowToProgram,
  programControllerGetAllProgramsForUser,
  programControllerAssignUsersToProgram,
  programControllerUnassignUsersFromProgram,
  workflowControllerGetWorkflows,
  workflowControllerCreateWorkflow,
  workflowControllerSearchWorkflows,
  workflowControllerFindWorkflowById,
  workflowControllerUpdateWorkflowBasicInfo,
  workflowControllerArchiveWorkflow,
  workflowControllerAssignUsersToWorkflow,
  workflowControllerUnassignUsersFromWorkflow,
  fieldControllerGetWorkflowFields,
  fieldControllerUpsertWorkflowFields,
  fieldControllerRemoveWorkflowField,
  configurationControllerGetWorkflowConfigurations,
  configurationControllerUpsertWorkflowConfigurations,
  configurationControllerRemoveWorkflowConfiguration,
  fieldMappingControllerGetWorkflowFieldMappings,
  fieldMappingControllerUpsertFieldMappings,
  collectorControllerProcessAi,
  collectorControllerSubmitData,
  collectorControllerGetSubmissionHistory,
  collectorControllerGetSubmissionById,
  integrationControllerTestConnection,
  integrationControllerFetchSchemas,
  integrationControllerGetPrograms,
  integrationControllerGetDatasets,
  integrationControllerGetOrgUnits,
  externalConnectionsControllerFindAll,
  externalConnectionsControllerCreate,
  externalConnectionsControllerRemove,
  externalConnectionsControllerFindOne,
  externalConnectionsControllerUpdate,
} from '../sdk.gen';
import {
  type UseMutationOptions,
  type DefaultError,
  queryOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from '@tanstack/react-query';
import type {
  AuthControllerRegisterData,
  AuthControllerRegisterResponse,
  AuthControllerLoginData,
  AuthControllerLoginResponse,
  AuthControllerLogoutData,
  AuthControllerVerifyEmailData,
  AuthControllerResendVerificationData,
  AuthControllerForgotPasswordData,
  AuthControllerResetPasswordData,
  AuthControllerGetProfileData,
  AuthControllerRefreshTokenData,
  AuthControllerRefreshTokenResponse,
  UserControllerGetProfileData,
  UserControllerFindAllData,
  UserControllerFindAllForLoggedInUserData,
  UserControllerAssignRoleData,
  UserControllerGetAllRolesData,
  UserControllerRegisterSingleUserData,
  UserControllerBulkCreateData,
  UserControllerBulkCreateResponse,
  UserControllerGetAllPermissionsData,
  ProgramControllerGetProgramsData,
  ProgramControllerCreateData,
  ProgramControllerCreateResponse,
  ProgramControllerRemoveData,
  ProgramControllerFindOneData,
  ProgramControllerUpdateData,
  ProgramControllerUpdateResponse,
  ProgramControllerFindWorkflowsByProgramData,
  ProgramControllerAddWorkflowToProgramData,
  ProgramControllerAddWorkflowToProgramResponse,
  ProgramControllerGetAllProgramsForUserData,
  ProgramControllerAssignUsersToProgramData,
  ProgramControllerAssignUsersToProgramResponse,
  ProgramControllerUnassignUsersFromProgramData,
  ProgramControllerUnassignUsersFromProgramResponse,
  WorkflowControllerGetWorkflowsData,
  WorkflowControllerCreateWorkflowData,
  WorkflowControllerCreateWorkflowResponse,
  WorkflowControllerSearchWorkflowsData,
  WorkflowControllerFindWorkflowByIdData,
  WorkflowControllerUpdateWorkflowBasicInfoData,
  WorkflowControllerUpdateWorkflowBasicInfoResponse,
  WorkflowControllerArchiveWorkflowData,
  WorkflowControllerAssignUsersToWorkflowData,
  WorkflowControllerAssignUsersToWorkflowResponse,
  WorkflowControllerUnassignUsersFromWorkflowData,
  WorkflowControllerUnassignUsersFromWorkflowResponse,
  FieldControllerGetWorkflowFieldsData,
  FieldControllerUpsertWorkflowFieldsData,
  FieldControllerRemoveWorkflowFieldData,
  ConfigurationControllerGetWorkflowConfigurationsData,
  ConfigurationControllerUpsertWorkflowConfigurationsData,
  ConfigurationControllerUpsertWorkflowConfigurationsResponse,
  ConfigurationControllerRemoveWorkflowConfigurationData,
  FieldMappingControllerGetWorkflowFieldMappingsData,
  FieldMappingControllerUpsertFieldMappingsData,
  CollectorControllerProcessAiData,
  CollectorControllerProcessAiResponse,
  CollectorControllerSubmitDataData,
  CollectorControllerGetSubmissionHistoryData,
  CollectorControllerGetSubmissionByIdData,
  IntegrationControllerTestConnectionData,
  IntegrationControllerTestConnectionResponse,
  IntegrationControllerFetchSchemasData,
  IntegrationControllerGetProgramsData,
  IntegrationControllerGetProgramsResponse,
  IntegrationControllerGetDatasetsData,
  IntegrationControllerGetDatasetsResponse,
  IntegrationControllerGetOrgUnitsData,
  ExternalConnectionsControllerFindAllData,
  ExternalConnectionsControllerCreateData,
  ExternalConnectionsControllerRemoveData,
  ExternalConnectionsControllerFindOneData,
  ExternalConnectionsControllerUpdateData,
  ExternalConnectionsControllerUpdateResponse,
} from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

/**
 * Register a new user
 */
export const authControllerRegisterMutation = (
  options?: Partial<Options<AuthControllerRegisterData>>
): UseMutationOptions<
  AuthControllerRegisterResponse,
  DefaultError,
  Options<AuthControllerRegisterData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthControllerRegisterResponse,
    DefaultError,
    Options<AuthControllerRegisterData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerRegister({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login an existing user
 */
export const authControllerLoginMutation = (
  options?: Partial<Options<AuthControllerLoginData>>
): UseMutationOptions<
  AuthControllerLoginResponse,
  DefaultError,
  Options<AuthControllerLoginData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthControllerLoginResponse,
    DefaultError,
    Options<AuthControllerLoginData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerLogin({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout the currently authenticated user
 */
export const authControllerLogoutMutation = (
  options?: Partial<Options<AuthControllerLogoutData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthControllerLogoutData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthControllerLogoutData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerLogout({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Verify a user's email address
 */
export const authControllerVerifyEmailMutation = (
  options?: Partial<Options<AuthControllerVerifyEmailData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthControllerVerifyEmailData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthControllerVerifyEmailData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerVerifyEmail({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Resend the email verification link
 */
export const authControllerResendVerificationMutation = (
  options?: Partial<Options<AuthControllerResendVerificationData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthControllerResendVerificationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthControllerResendVerificationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerResendVerification({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Request a password reset link
 */
export const authControllerForgotPasswordMutation = (
  options?: Partial<Options<AuthControllerForgotPasswordData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthControllerForgotPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthControllerForgotPasswordData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerForgotPassword({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reset a user's password
 */
export const authControllerResetPasswordMutation = (
  options?: Partial<Options<AuthControllerResetPasswordData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthControllerResetPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthControllerResetPasswordData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerResetPassword({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl ||
      (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const authControllerGetProfileQueryKey = (
  options?: Options<AuthControllerGetProfileData>
) => createQueryKey('authControllerGetProfile', options);

/**
 * Get the profile of the currently authenticated user
 */
export const authControllerGetProfileOptions = (
  options?: Options<AuthControllerGetProfileData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authControllerGetProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authControllerGetProfileQueryKey(options),
  });
};

/**
 * Refresh authentication token
 * Generates a new access token using a valid refresh token.
 * Requires valid JWT authentication.
 */
export const authControllerRefreshTokenMutation = (
  options?: Partial<Options<AuthControllerRefreshTokenData>>
): UseMutationOptions<
  AuthControllerRefreshTokenResponse,
  DefaultError,
  Options<AuthControllerRefreshTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthControllerRefreshTokenResponse,
    DefaultError,
    Options<AuthControllerRefreshTokenData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await authControllerRefreshToken({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userControllerGetProfileQueryKey = (
  options?: Options<UserControllerGetProfileData>
) => createQueryKey('userControllerGetProfile', options);

export const userControllerGetProfileOptions = (
  options?: Options<UserControllerGetProfileData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerGetProfile({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerGetProfileQueryKey(options),
  });
};

export const userControllerFindAllQueryKey = (
  options: Options<UserControllerFindAllData>
) => createQueryKey('userControllerFindAll', options);

export const userControllerFindAllOptions = (
  options: Options<UserControllerFindAllData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerFindAll({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerFindAllQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const userControllerFindAllInfiniteQueryKey = (
  options: Options<UserControllerFindAllData>
): QueryKey<Options<UserControllerFindAllData>> =>
  createQueryKey('userControllerFindAll', options, true);

export const userControllerFindAllInfiniteOptions = (
  options: Options<UserControllerFindAllData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<UserControllerFindAllData>>,
    | number
    | Pick<
        QueryKey<Options<UserControllerFindAllData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<UserControllerFindAllData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await userControllerFindAll({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: userControllerFindAllInfiniteQueryKey(options),
    }
  );
};

export const userControllerFindAllForLoggedInUserQueryKey = (
  options: Options<UserControllerFindAllForLoggedInUserData>
) => createQueryKey('userControllerFindAllForLoggedInUser', options);

export const userControllerFindAllForLoggedInUserOptions = (
  options: Options<UserControllerFindAllForLoggedInUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerFindAllForLoggedInUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerFindAllForLoggedInUserQueryKey(options),
  });
};

export const userControllerFindAllForLoggedInUserInfiniteQueryKey = (
  options: Options<UserControllerFindAllForLoggedInUserData>
): QueryKey<Options<UserControllerFindAllForLoggedInUserData>> =>
  createQueryKey('userControllerFindAllForLoggedInUser', options, true);

export const userControllerFindAllForLoggedInUserInfiniteOptions = (
  options: Options<UserControllerFindAllForLoggedInUserData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<UserControllerFindAllForLoggedInUserData>>,
    | number
    | Pick<
        QueryKey<Options<UserControllerFindAllForLoggedInUserData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<UserControllerFindAllForLoggedInUserData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await userControllerFindAllForLoggedInUser({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: userControllerFindAllForLoggedInUserInfiniteQueryKey(options),
    }
  );
};

export const userControllerAssignRoleMutation = (
  options?: Partial<Options<UserControllerAssignRoleData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UserControllerAssignRoleData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UserControllerAssignRoleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await userControllerAssignRole({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userControllerGetAllRolesQueryKey = (
  options?: Options<UserControllerGetAllRolesData>
) => createQueryKey('userControllerGetAllRoles', options);

export const userControllerGetAllRolesOptions = (
  options?: Options<UserControllerGetAllRolesData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerGetAllRoles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerGetAllRolesQueryKey(options),
  });
};

export const userControllerRegisterSingleUserMutation = (
  options?: Partial<Options<UserControllerRegisterSingleUserData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UserControllerRegisterSingleUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UserControllerRegisterSingleUserData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await userControllerRegisterSingleUser({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Bulk create users from CSV
 * Upload a CSV file to create multiple users at once.
 *
 * **CSV Format:**
 * - Headers: email, password, firstName, lastName
 * - Password requirements: Min 8 chars, 1 uppercase, 1 lowercase, 1 number, 1 special character (@$!%*?&)
 */
export const userControllerBulkCreateMutation = (
  options?: Partial<Options<UserControllerBulkCreateData>>
): UseMutationOptions<
  UserControllerBulkCreateResponse,
  DefaultError,
  Options<UserControllerBulkCreateData>
> => {
  const mutationOptions: UseMutationOptions<
    UserControllerBulkCreateResponse,
    DefaultError,
    Options<UserControllerBulkCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await userControllerBulkCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userControllerGetAllPermissionsQueryKey = (
  options?: Options<UserControllerGetAllPermissionsData>
) => createQueryKey('userControllerGetAllPermissions', options);

export const userControllerGetAllPermissionsOptions = (
  options?: Options<UserControllerGetAllPermissionsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerGetAllPermissions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerGetAllPermissionsQueryKey(options),
  });
};

export const programControllerGetProgramsQueryKey = (
  options?: Options<ProgramControllerGetProgramsData>
) => createQueryKey('programControllerGetPrograms', options);

/**
 * Get all programs with pagination
 */
export const programControllerGetProgramsOptions = (
  options?: Options<ProgramControllerGetProgramsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await programControllerGetPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: programControllerGetProgramsQueryKey(options),
  });
};

export const programControllerGetProgramsInfiniteQueryKey = (
  options?: Options<ProgramControllerGetProgramsData>
): QueryKey<Options<ProgramControllerGetProgramsData>> =>
  createQueryKey('programControllerGetPrograms', options, true);

/**
 * Get all programs with pagination
 */
export const programControllerGetProgramsInfiniteOptions = (
  options?: Options<ProgramControllerGetProgramsData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<ProgramControllerGetProgramsData>>,
    | number
    | Pick<
        QueryKey<Options<ProgramControllerGetProgramsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ProgramControllerGetProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await programControllerGetPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: programControllerGetProgramsInfiniteQueryKey(options),
    }
  );
};

/**
 * Create a new program
 */
export const programControllerCreateMutation = (
  options?: Partial<Options<ProgramControllerCreateData>>
): UseMutationOptions<
  ProgramControllerCreateResponse,
  DefaultError,
  Options<ProgramControllerCreateData>
> => {
  const mutationOptions: UseMutationOptions<
    ProgramControllerCreateResponse,
    DefaultError,
    Options<ProgramControllerCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a specific program by ID
 */
export const programControllerRemoveMutation = (
  options?: Partial<Options<ProgramControllerRemoveData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<ProgramControllerRemoveData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<ProgramControllerRemoveData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerRemove({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const programControllerFindOneQueryKey = (
  options: Options<ProgramControllerFindOneData>
) => createQueryKey('programControllerFindOne', options);

/**
 * Get a specific program by ID
 */
export const programControllerFindOneOptions = (
  options: Options<ProgramControllerFindOneData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await programControllerFindOne({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: programControllerFindOneQueryKey(options),
  });
};

/**
 * Update a specific program by ID
 */
export const programControllerUpdateMutation = (
  options?: Partial<Options<ProgramControllerUpdateData>>
): UseMutationOptions<
  ProgramControllerUpdateResponse,
  DefaultError,
  Options<ProgramControllerUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    ProgramControllerUpdateResponse,
    DefaultError,
    Options<ProgramControllerUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const programControllerFindWorkflowsByProgramQueryKey = (
  options: Options<ProgramControllerFindWorkflowsByProgramData>
) => createQueryKey('programControllerFindWorkflowsByProgram', options);

/**
 * Get all workflows associated with a specific program
 */
export const programControllerFindWorkflowsByProgramOptions = (
  options: Options<ProgramControllerFindWorkflowsByProgramData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await programControllerFindWorkflowsByProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: programControllerFindWorkflowsByProgramQueryKey(options),
  });
};

/**
 * Associate multiple workflows with a specific program
 */
export const programControllerAddWorkflowToProgramMutation = (
  options?: Partial<Options<ProgramControllerAddWorkflowToProgramData>>
): UseMutationOptions<
  ProgramControllerAddWorkflowToProgramResponse,
  DefaultError,
  Options<ProgramControllerAddWorkflowToProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    ProgramControllerAddWorkflowToProgramResponse,
    DefaultError,
    Options<ProgramControllerAddWorkflowToProgramData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerAddWorkflowToProgram({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const programControllerGetAllProgramsForUserQueryKey = (
  options: Options<ProgramControllerGetAllProgramsForUserData>
) => createQueryKey('programControllerGetAllProgramsForUser', options);

/**
 * Get all programs associated with a specific user
 */
export const programControllerGetAllProgramsForUserOptions = (
  options: Options<ProgramControllerGetAllProgramsForUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await programControllerGetAllProgramsForUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: programControllerGetAllProgramsForUserQueryKey(options),
  });
};

/**
 * Assign multiple users to a specific program
 */
export const programControllerAssignUsersToProgramMutation = (
  options?: Partial<Options<ProgramControllerAssignUsersToProgramData>>
): UseMutationOptions<
  ProgramControllerAssignUsersToProgramResponse,
  DefaultError,
  Options<ProgramControllerAssignUsersToProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    ProgramControllerAssignUsersToProgramResponse,
    DefaultError,
    Options<ProgramControllerAssignUsersToProgramData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerAssignUsersToProgram({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const programControllerUnassignUsersFromProgramMutation = (
  options?: Partial<Options<ProgramControllerUnassignUsersFromProgramData>>
): UseMutationOptions<
  ProgramControllerUnassignUsersFromProgramResponse,
  DefaultError,
  Options<ProgramControllerUnassignUsersFromProgramData>
> => {
  const mutationOptions: UseMutationOptions<
    ProgramControllerUnassignUsersFromProgramResponse,
    DefaultError,
    Options<ProgramControllerUnassignUsersFromProgramData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await programControllerUnassignUsersFromProgram({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const workflowControllerGetWorkflowsQueryKey = (
  options?: Options<WorkflowControllerGetWorkflowsData>
) => createQueryKey('workflowControllerGetWorkflows', options);

export const workflowControllerGetWorkflowsOptions = (
  options?: Options<WorkflowControllerGetWorkflowsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await workflowControllerGetWorkflows({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: workflowControllerGetWorkflowsQueryKey(options),
  });
};

export const workflowControllerGetWorkflowsInfiniteQueryKey = (
  options?: Options<WorkflowControllerGetWorkflowsData>
): QueryKey<Options<WorkflowControllerGetWorkflowsData>> =>
  createQueryKey('workflowControllerGetWorkflows', options, true);

export const workflowControllerGetWorkflowsInfiniteOptions = (
  options?: Options<WorkflowControllerGetWorkflowsData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<WorkflowControllerGetWorkflowsData>>,
    | number
    | Pick<
        QueryKey<Options<WorkflowControllerGetWorkflowsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<WorkflowControllerGetWorkflowsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await workflowControllerGetWorkflows({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: workflowControllerGetWorkflowsInfiniteQueryKey(options),
    }
  );
};

export const workflowControllerCreateWorkflowMutation = (
  options?: Partial<Options<WorkflowControllerCreateWorkflowData>>
): UseMutationOptions<
  WorkflowControllerCreateWorkflowResponse,
  DefaultError,
  Options<WorkflowControllerCreateWorkflowData>
> => {
  const mutationOptions: UseMutationOptions<
    WorkflowControllerCreateWorkflowResponse,
    DefaultError,
    Options<WorkflowControllerCreateWorkflowData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await workflowControllerCreateWorkflow({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const workflowControllerSearchWorkflowsQueryKey = (
  options: Options<WorkflowControllerSearchWorkflowsData>
) => createQueryKey('workflowControllerSearchWorkflows', options);

export const workflowControllerSearchWorkflowsOptions = (
  options: Options<WorkflowControllerSearchWorkflowsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await workflowControllerSearchWorkflows({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: workflowControllerSearchWorkflowsQueryKey(options),
  });
};

export const workflowControllerSearchWorkflowsInfiniteQueryKey = (
  options: Options<WorkflowControllerSearchWorkflowsData>
): QueryKey<Options<WorkflowControllerSearchWorkflowsData>> =>
  createQueryKey('workflowControllerSearchWorkflows', options, true);

export const workflowControllerSearchWorkflowsInfiniteOptions = (
  options: Options<WorkflowControllerSearchWorkflowsData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<WorkflowControllerSearchWorkflowsData>>,
    | number
    | Pick<
        QueryKey<Options<WorkflowControllerSearchWorkflowsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<WorkflowControllerSearchWorkflowsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await workflowControllerSearchWorkflows({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: workflowControllerSearchWorkflowsInfiniteQueryKey(options),
    }
  );
};

export const workflowControllerFindWorkflowByIdQueryKey = (
  options: Options<WorkflowControllerFindWorkflowByIdData>
) => createQueryKey('workflowControllerFindWorkflowById', options);

export const workflowControllerFindWorkflowByIdOptions = (
  options: Options<WorkflowControllerFindWorkflowByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await workflowControllerFindWorkflowById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: workflowControllerFindWorkflowByIdQueryKey(options),
  });
};

export const workflowControllerUpdateWorkflowBasicInfoMutation = (
  options?: Partial<Options<WorkflowControllerUpdateWorkflowBasicInfoData>>
): UseMutationOptions<
  WorkflowControllerUpdateWorkflowBasicInfoResponse,
  DefaultError,
  Options<WorkflowControllerUpdateWorkflowBasicInfoData>
> => {
  const mutationOptions: UseMutationOptions<
    WorkflowControllerUpdateWorkflowBasicInfoResponse,
    DefaultError,
    Options<WorkflowControllerUpdateWorkflowBasicInfoData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await workflowControllerUpdateWorkflowBasicInfo({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const workflowControllerArchiveWorkflowMutation = (
  options?: Partial<Options<WorkflowControllerArchiveWorkflowData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<WorkflowControllerArchiveWorkflowData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<WorkflowControllerArchiveWorkflowData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await workflowControllerArchiveWorkflow({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const workflowControllerAssignUsersToWorkflowMutation = (
  options?: Partial<Options<WorkflowControllerAssignUsersToWorkflowData>>
): UseMutationOptions<
  WorkflowControllerAssignUsersToWorkflowResponse,
  DefaultError,
  Options<WorkflowControllerAssignUsersToWorkflowData>
> => {
  const mutationOptions: UseMutationOptions<
    WorkflowControllerAssignUsersToWorkflowResponse,
    DefaultError,
    Options<WorkflowControllerAssignUsersToWorkflowData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await workflowControllerAssignUsersToWorkflow({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const workflowControllerUnassignUsersFromWorkflowMutation = (
  options?: Partial<Options<WorkflowControllerUnassignUsersFromWorkflowData>>
): UseMutationOptions<
  WorkflowControllerUnassignUsersFromWorkflowResponse,
  DefaultError,
  Options<WorkflowControllerUnassignUsersFromWorkflowData>
> => {
  const mutationOptions: UseMutationOptions<
    WorkflowControllerUnassignUsersFromWorkflowResponse,
    DefaultError,
    Options<WorkflowControllerUnassignUsersFromWorkflowData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await workflowControllerUnassignUsersFromWorkflow({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const fieldControllerGetWorkflowFieldsQueryKey = (
  options: Options<FieldControllerGetWorkflowFieldsData>
) => createQueryKey('fieldControllerGetWorkflowFields', options);

export const fieldControllerGetWorkflowFieldsOptions = (
  options: Options<FieldControllerGetWorkflowFieldsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await fieldControllerGetWorkflowFields({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: fieldControllerGetWorkflowFieldsQueryKey(options),
  });
};

export const fieldControllerUpsertWorkflowFieldsMutation = (
  options?: Partial<Options<FieldControllerUpsertWorkflowFieldsData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<FieldControllerUpsertWorkflowFieldsData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<FieldControllerUpsertWorkflowFieldsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await fieldControllerUpsertWorkflowFields({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const fieldControllerRemoveWorkflowFieldMutation = (
  options?: Partial<Options<FieldControllerRemoveWorkflowFieldData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<FieldControllerRemoveWorkflowFieldData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<FieldControllerRemoveWorkflowFieldData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await fieldControllerRemoveWorkflowField({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const configurationControllerGetWorkflowConfigurationsQueryKey = (
  options: Options<ConfigurationControllerGetWorkflowConfigurationsData>
) =>
  createQueryKey('configurationControllerGetWorkflowConfigurations', options);

export const configurationControllerGetWorkflowConfigurationsOptions = (
  options: Options<ConfigurationControllerGetWorkflowConfigurationsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await configurationControllerGetWorkflowConfigurations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: configurationControllerGetWorkflowConfigurationsQueryKey(options),
  });
};

export const configurationControllerUpsertWorkflowConfigurationsMutation = (
  options?: Partial<
    Options<ConfigurationControllerUpsertWorkflowConfigurationsData>
  >
): UseMutationOptions<
  ConfigurationControllerUpsertWorkflowConfigurationsResponse,
  DefaultError,
  Options<ConfigurationControllerUpsertWorkflowConfigurationsData>
> => {
  const mutationOptions: UseMutationOptions<
    ConfigurationControllerUpsertWorkflowConfigurationsResponse,
    DefaultError,
    Options<ConfigurationControllerUpsertWorkflowConfigurationsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } =
        await configurationControllerUpsertWorkflowConfigurations({
          ...options,
          ...fnOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const configurationControllerRemoveWorkflowConfigurationMutation = (
  options?: Partial<
    Options<ConfigurationControllerRemoveWorkflowConfigurationData>
  >
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<ConfigurationControllerRemoveWorkflowConfigurationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<ConfigurationControllerRemoveWorkflowConfigurationData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await configurationControllerRemoveWorkflowConfiguration(
        {
          ...options,
          ...fnOptions,
          throwOnError: true,
        }
      );
      return data;
    },
  };
  return mutationOptions;
};

export const fieldMappingControllerGetWorkflowFieldMappingsQueryKey = (
  options: Options<FieldMappingControllerGetWorkflowFieldMappingsData>
) => createQueryKey('fieldMappingControllerGetWorkflowFieldMappings', options);

export const fieldMappingControllerGetWorkflowFieldMappingsOptions = (
  options: Options<FieldMappingControllerGetWorkflowFieldMappingsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await fieldMappingControllerGetWorkflowFieldMappings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: fieldMappingControllerGetWorkflowFieldMappingsQueryKey(options),
  });
};

export const fieldMappingControllerUpsertFieldMappingsMutation = (
  options?: Partial<Options<FieldMappingControllerUpsertFieldMappingsData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<FieldMappingControllerUpsertFieldMappingsData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<FieldMappingControllerUpsertFieldMappingsData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await fieldMappingControllerUpsertFieldMappings({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Process AI data
 * Accepts multiple files for processing AI data including text, audio, and images. Accepts language parameter for audio processing.
 */
export const collectorControllerProcessAiMutation = (
  options?: Partial<Options<CollectorControllerProcessAiData>>
): UseMutationOptions<
  CollectorControllerProcessAiResponse,
  DefaultError,
  Options<CollectorControllerProcessAiData>
> => {
  const mutationOptions: UseMutationOptions<
    CollectorControllerProcessAiResponse,
    DefaultError,
    Options<CollectorControllerProcessAiData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await collectorControllerProcessAi({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Submit collected data
 */
export const collectorControllerSubmitDataMutation = (
  options?: Partial<Options<CollectorControllerSubmitDataData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<CollectorControllerSubmitDataData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<CollectorControllerSubmitDataData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await collectorControllerSubmitData({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const collectorControllerGetSubmissionHistoryQueryKey = (
  options?: Options<CollectorControllerGetSubmissionHistoryData>
) => createQueryKey('collectorControllerGetSubmissionHistory', options);

/**
 * Get submission history - scoped by role:
 * - Users: Only their own submissions
 * - Admins: Submissions from users they created
 * - Super-admins: All submissions
 */
export const collectorControllerGetSubmissionHistoryOptions = (
  options?: Options<CollectorControllerGetSubmissionHistoryData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await collectorControllerGetSubmissionHistory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: collectorControllerGetSubmissionHistoryQueryKey(options),
  });
};

export const collectorControllerGetSubmissionHistoryInfiniteQueryKey = (
  options?: Options<CollectorControllerGetSubmissionHistoryData>
): QueryKey<Options<CollectorControllerGetSubmissionHistoryData>> =>
  createQueryKey('collectorControllerGetSubmissionHistory', options, true);

/**
 * Get submission history - scoped by role:
 * - Users: Only their own submissions
 * - Admins: Submissions from users they created
 * - Super-admins: All submissions
 */
export const collectorControllerGetSubmissionHistoryInfiniteOptions = (
  options?: Options<CollectorControllerGetSubmissionHistoryData>
) => {
  return infiniteQueryOptions<
    unknown,
    DefaultError,
    InfiniteData<unknown>,
    QueryKey<Options<CollectorControllerGetSubmissionHistoryData>>,
    | number
    | Pick<
        QueryKey<Options<CollectorControllerGetSubmissionHistoryData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<CollectorControllerGetSubmissionHistoryData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await collectorControllerGetSubmissionHistory({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey:
        collectorControllerGetSubmissionHistoryInfiniteQueryKey(options),
    }
  );
};

export const collectorControllerGetSubmissionByIdQueryKey = (
  options: Options<CollectorControllerGetSubmissionByIdData>
) => createQueryKey('collectorControllerGetSubmissionById', options);

/**
 * Get a single submission by ID - scoped by role:
 * - Users: Only their own submissions
 * - Admins: Submissions from users they created
 * - Super-admins: All submissions
 */
export const collectorControllerGetSubmissionByIdOptions = (
  options: Options<CollectorControllerGetSubmissionByIdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await collectorControllerGetSubmissionById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: collectorControllerGetSubmissionByIdQueryKey(options),
  });
};

/**
 * Confirm connection
 */
export const integrationControllerTestConnectionMutation = (
  options?: Partial<Options<IntegrationControllerTestConnectionData>>
): UseMutationOptions<
  IntegrationControllerTestConnectionResponse,
  DefaultError,
  Options<IntegrationControllerTestConnectionData>
> => {
  const mutationOptions: UseMutationOptions<
    IntegrationControllerTestConnectionResponse,
    DefaultError,
    Options<IntegrationControllerTestConnectionData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await integrationControllerTestConnection({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const integrationControllerFetchSchemasQueryKey = (
  options: Options<IntegrationControllerFetchSchemasData>
) => createQueryKey('integrationControllerFetchSchemas', options);

/**
 * Fetch schemas
 */
export const integrationControllerFetchSchemasOptions = (
  options: Options<IntegrationControllerFetchSchemasData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await integrationControllerFetchSchemas({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: integrationControllerFetchSchemasQueryKey(options),
  });
};

export const integrationControllerGetProgramsQueryKey = (
  options: Options<IntegrationControllerGetProgramsData>
) => createQueryKey('integrationControllerGetPrograms', options);

export const integrationControllerGetProgramsOptions = (
  options: Options<IntegrationControllerGetProgramsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await integrationControllerGetPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: integrationControllerGetProgramsQueryKey(options),
  });
};

export const integrationControllerGetProgramsInfiniteQueryKey = (
  options: Options<IntegrationControllerGetProgramsData>
): QueryKey<Options<IntegrationControllerGetProgramsData>> =>
  createQueryKey('integrationControllerGetPrograms', options, true);

export const integrationControllerGetProgramsInfiniteOptions = (
  options: Options<IntegrationControllerGetProgramsData>
) => {
  return infiniteQueryOptions<
    IntegrationControllerGetProgramsResponse,
    DefaultError,
    InfiniteData<IntegrationControllerGetProgramsResponse>,
    QueryKey<Options<IntegrationControllerGetProgramsData>>,
    | number
    | Pick<
        QueryKey<Options<IntegrationControllerGetProgramsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<IntegrationControllerGetProgramsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await integrationControllerGetPrograms({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: integrationControllerGetProgramsInfiniteQueryKey(options),
    }
  );
};

export const integrationControllerGetDatasetsQueryKey = (
  options: Options<IntegrationControllerGetDatasetsData>
) => createQueryKey('integrationControllerGetDatasets', options);

export const integrationControllerGetDatasetsOptions = (
  options: Options<IntegrationControllerGetDatasetsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await integrationControllerGetDatasets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: integrationControllerGetDatasetsQueryKey(options),
  });
};

export const integrationControllerGetDatasetsInfiniteQueryKey = (
  options: Options<IntegrationControllerGetDatasetsData>
): QueryKey<Options<IntegrationControllerGetDatasetsData>> =>
  createQueryKey('integrationControllerGetDatasets', options, true);

export const integrationControllerGetDatasetsInfiniteOptions = (
  options: Options<IntegrationControllerGetDatasetsData>
) => {
  return infiniteQueryOptions<
    IntegrationControllerGetDatasetsResponse,
    DefaultError,
    InfiniteData<IntegrationControllerGetDatasetsResponse>,
    QueryKey<Options<IntegrationControllerGetDatasetsData>>,
    | number
    | Pick<
        QueryKey<Options<IntegrationControllerGetDatasetsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<IntegrationControllerGetDatasetsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await integrationControllerGetDatasets({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: integrationControllerGetDatasetsInfiniteQueryKey(options),
    }
  );
};

export const integrationControllerGetOrgUnitsQueryKey = (
  options: Options<IntegrationControllerGetOrgUnitsData>
) => createQueryKey('integrationControllerGetOrgUnits', options);

export const integrationControllerGetOrgUnitsOptions = (
  options: Options<IntegrationControllerGetOrgUnitsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await integrationControllerGetOrgUnits({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: integrationControllerGetOrgUnitsQueryKey(options),
  });
};

export const externalConnectionsControllerFindAllQueryKey = (
  options?: Options<ExternalConnectionsControllerFindAllData>
) => createQueryKey('externalConnectionsControllerFindAll', options);

export const externalConnectionsControllerFindAllOptions = (
  options?: Options<ExternalConnectionsControllerFindAllData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await externalConnectionsControllerFindAll({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: externalConnectionsControllerFindAllQueryKey(options),
  });
};

export const externalConnectionsControllerCreateMutation = (
  options?: Partial<Options<ExternalConnectionsControllerCreateData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<ExternalConnectionsControllerCreateData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<ExternalConnectionsControllerCreateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await externalConnectionsControllerCreate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const externalConnectionsControllerRemoveMutation = (
  options?: Partial<Options<ExternalConnectionsControllerRemoveData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<ExternalConnectionsControllerRemoveData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<ExternalConnectionsControllerRemoveData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await externalConnectionsControllerRemove({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const externalConnectionsControllerFindOneQueryKey = (
  options: Options<ExternalConnectionsControllerFindOneData>
) => createQueryKey('externalConnectionsControllerFindOne', options);

export const externalConnectionsControllerFindOneOptions = (
  options: Options<ExternalConnectionsControllerFindOneData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await externalConnectionsControllerFindOne({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: externalConnectionsControllerFindOneQueryKey(options),
  });
};

export const externalConnectionsControllerUpdateMutation = (
  options?: Partial<Options<ExternalConnectionsControllerUpdateData>>
): UseMutationOptions<
  ExternalConnectionsControllerUpdateResponse,
  DefaultError,
  Options<ExternalConnectionsControllerUpdateData>
> => {
  const mutationOptions: UseMutationOptions<
    ExternalConnectionsControllerUpdateResponse,
    DefaultError,
    Options<ExternalConnectionsControllerUpdateData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await externalConnectionsControllerUpdate({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
